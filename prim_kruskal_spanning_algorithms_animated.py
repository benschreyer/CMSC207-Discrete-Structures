#Benjamin Schreyer 2/7/2021 Animated Minimum Spanning Tree Algorithms
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
import time
import scipy
import random






def binary_search_insert(key,lst):
    binary_search_insert(key,lst,0,len(lst))

#Function to conveniently plot graphs that are stored as a list of vertices and a list of adjacencies
def plot_graph(vertices,edges,pause,sp):
    #clear the graph being plotted for animation use
    sp.cla()

    #create and populate the graph object with our graph datastructure
    g = nx.Graph()
    for n in vertices:
        g.add_node(n)

    for e in edges:
        g.add_edge(e[0],e[1],weight = e[2])

    #define a graph layout to use and draw the graph specified
    pos=nx.shell_layout(g)
    nx.draw_networkx(g,pos)
    labels = nx.get_edge_attributes(g,'weight')

    nx.draw_networkx_edge_labels(g,pos,edge_labels = labels)

    #hold code execution for the animation frame duration and update graph
    plt.draw()
    plt.show()
    plt.pause(pause)

#Define a weighted graph by vertex set and edge set

my_vertices = ["A", "B", "C", "D", "E", "F", "G"]
my_edges = []#[("A","D",1),("B","C",6),("B","G",6),("C","D",3),("E","D",4),("F","D",4),("F","E",3),("G","F",2),("A","G",3),("A","B",5),("C","G",5),("E","B",4),("D","B",4),("F","A",2)]
for i in range(len(my_vertices)):
    for j in range(i+1,len(my_vertices)):
        v = my_vertices[i]
        v2 = my_vertices[j]
        if(v2 == v):
            continue
        if random.randint(0,6) > 2:
            my_edges.append((v,v2,random.randint(1,9)))
print(my_edges)
#Show a two graph window
plt.ion()
plt.subplots(1,2)
plt.show()

#Plot the full view of the graph
static_subplot = plt.subplot(1,2,1)
plot_graph(my_vertices,my_edges,1,static_subplot)

#Save the animated plot instance so we can draw new frames on it using graph function
animated_plot = plt.subplot(1,2,2)

#Edges of the second minimum spanning tree to be generated by Kruskal's algorithm
mst_edges = []

#Kruskal's algorithm

#Create a list of graph edges sorted by weight
weight_sorted_edges = my_edges
weight_sorted_edges.sort(key = lambda x:x[2])

#Create a set of sets where each set is a connected subtree, initially this will just be each vertex as its own connected subtree.
#The subtree vertex sets will be combined until all the vertices are in one subtree meaning the graph has been spanned
disjoint_sets = []
for vertex in my_vertices:
    disjoint_sets.append([vertex])

#Iterate the weight sorted edges from least to greatest weight
for edge in weight_sorted_edges:

    #Show the edge we are looking at and the subtree vertices in the console
    print(edge,disjoint_sets)

    #Determine whether the current considered edge connects two unconnected subtrees, if they do not skip this iteration. cont is the flag for continuing
    cont = False
    for i in range(len(disjoint_sets)):
        if(edge[1] in disjoint_sets[i] and edge[0] in disjoint_sets[i]):
            print("SKIPPED")
            cont = True

    if cont:
        continue

    #Add the edge to the spanning tree since the edge was determined to connect unconnected subtrees
    mst_edges.append(edge)

    #Combine the two subtree vertex sets by finding the subtree vertex set of one end of the edge, saving the vertices in its subtree, and then adding those vertices to the subtree
    #of the other vertex
    marker = 0

    #Find one of the two vertex subtree vertex sets
    for i in range(len(disjoint_sets)):
        if(edge[1] in disjoint_sets[i]):
            marker = i
    #Save the vertices in it into temp
    temp = list(disjoint_sets[marker])
    #Remove the set from the set of subtree vertex sets
    disjoint_sets.remove(disjoint_sets[marker])

    #Find the vertex set of the other edge end subtree to add temp two, making the union of the two sets
    for i in range(len(disjoint_sets)):
        if(edge[0] in disjoint_sets[i]):
            marker = i

    #Combine the sets to perform union operation
    for v in temp:
        disjoint_sets[marker].append(v)

    print(len(disjoint_sets))
    #Show the animation frame of adding the edge
    if(len(disjoint_sets) == 1):
        plot_graph(my_vertices,mst_edges,8,animated_plot)
    else:
        plot_graph(my_vertices,mst_edges,1,animated_plot)



#Prim's algorithm, could definetly be more efficent

mst_edges = []

visited = ["A"]

edge_queue = []

for edge in my_edges:
        if visited[-1] == edge[0]:
            edge_queue.append(edge)
        if visited[-1] == edge[1]:
            edge_queue.append(edge)
edge_queue.sort(key = lambda x:x[2])

#While the graph has not been spanned
while len(visited) < len(my_vertices):
    print(edge_queue)
    #keep window open when animation is done
    if len(visited)  == (len(my_vertices) - 1):
        plt.ioff()

    #Remove edges that are not connected to the growing subtree or are pointless to add
    while((edge_queue[0][1] in visited and edge_queue[0][0] in visited) or (not edge_queue[0][1] in visited and not edge_queue[0][0] in visited)):
        edge_queue.remove(edge_queue[0])

    #Take the lowest weight edge that expands the subtree
    if(len(edge_queue)==0):
        break
    mst_edges.append(edge_queue[0])
    edge_queue.remove(edge_queue[0])

    #Add the newly visited node to the subtree
    if(mst_edges[-1][0] in visited):
        visited.append(mst_edges[-1][1])
    else:
        visited.append(mst_edges[-1][0])

    #Add edges connected to the new vertex in the subtree and sort the edge list by weight to maintain min weight property
    for edge in my_edges:
        if visited[-1] == edge[0]:
            edge_queue.append(edge)
        if visited[-1] == edge[1]:
            edge_queue.append(edge)
    edge_queue.sort(key = lambda x:x[2])
    #Animation frame
    plot_graph(my_vertices,mst_edges,1,animated_plot)










